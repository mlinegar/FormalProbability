import FormalProbability.Econometrics.Assumptions
import Mathlib.MeasureTheory.Function.FactorsThrough
import Mathlib.MeasureTheory.Measure.Map
import Mathlib.MeasureTheory.MeasurableSpace.Constructions
import Mathlib.Topology.Metrizable.Basic

/-!
# FormalProbability/Econometrics/PropensityScore.lean

Propensity score definitions and basic properties.
-/

set_option linter.mathlibStandardSet false

open scoped Classical
open scoped MeasureTheory
open MeasureTheory

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Econometrics

/-!
## Propensity Score as a Random Variable
-/

/-- Propensity score as a random variable: e(ω) = E[D | X](ω). -/
def propensityScoreRV {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]
    (mu : Measure Ω) (X : Ω → α) (D : Ω → Treatment) : Ω → ℝ :=
  mu[fun ω => treatmentIndicator D ω | sigmaX X]

lemma propensityScoreRV_measurable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]
    (mu : Measure Ω) (X : Ω → α) (D : Ω → Treatment) :
    Measurable[sigmaX X] (propensityScoreRV mu X D) := by
  simpa [propensityScoreRV] using
    (MeasureTheory.stronglyMeasurable_condExp
      (μ := mu) (m := sigmaX X) (f := fun ω => treatmentIndicator D ω)).measurable

/-!
## Doob-Dynkin Factorization

If a random variable is measurable with respect to the sigma-algebra generated by `X`,
then it can be written as a measurable function of `X`. This is the Doob-Dynkin lemma,
and it is the formal basis for moving from

  e(omega) = E[D | X](omega)

to a function of covariates,

  e(x).

We include both exact and almost-everywhere versions, plus simple uniqueness facts
to make the statement usable as a textbook reference.
-/

section DoobDynkin

variable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]

section Basic

variable {β : Type*} [MeasurableSpace β]

/-- If `g = h ∘ X` for a measurable `h`, then `g` is measurable with respect to `sigmaX X`. -/
theorem measurable_sigmaX_of_comp (X : Ω → α) (h : α → β) (hh : Measurable h) :
    Measurable[sigmaX X] (h ∘ X) := by
  have hX : Measurable[sigmaX X] X := by
    simpa [sigmaX] using (comap_measurable (f := X))
  simpa using hh.comp hX

/-!
### Qualitative Dependence
-/

/-- A sigmaX-measurable random variable depends only on `X`. -/
theorem factorsThrough_sigmaX {β' : Type*} [MeasurableSpace β']
    [MeasurableSingletonClass β'] (X : Ω → α) (g : Ω → β')
    (hg : Measurable[sigmaX X] g) : g.FactorsThrough X := by
  have hg' : Measurable[MeasurableSpace.comap X (inferInstance : MeasurableSpace α)] g := by
    simpa [sigmaX] using hg
  exact (Measurable.factorsThrough (f := X) (g := g) hg')

/-!
### Uniqueness (on the range of X)
-/

/-- If two functions agree after composing with `X`, they agree on the range of `X`. -/
theorem doobDynkin_unique_on_range (X : Ω → α) (h1 h2 : α → β)
    (h_eq : h1 ∘ X = h2 ∘ X) : Set.EqOn h1 h2 (Set.range X) := by
  intro x hx
  rcases hx with ⟨ω, rfl⟩
  simpa [Function.comp] using congrArg (fun f => f ω) h_eq

/-- If `X` is surjective, the factorization is unique. -/
theorem doobDynkin_unique_of_surjective (X : Ω → α) (h1 h2 : α → β)
    (hX : Function.Surjective X) (h_eq : h1 ∘ X = h2 ∘ X) : h1 = h2 := by
  funext x
  rcases hX x with ⟨ω, rfl⟩
  simpa [Function.comp] using congrArg (fun f => f ω) h_eq

/-!
### Uniqueness (a.e. with respect to μ ∘ X⁻¹)
-/

/-- If `h1 ∘ X = h2 ∘ X` a.e., then `h1 = h2` a.e. under the pushforward measure `μ.map X`. -/
theorem doobDynkin_unique_ae_map {μ : Measure Ω} (X : Ω → α)
    (h1 h2 : α → β) [MeasurableEq β]
    (hX : AEMeasurable X μ) (h1m : Measurable h1) (h2m : Measurable h2)
    (h_eq : (h1 ∘ X) =ᵐ[μ] (h2 ∘ X)) :
    h1 =ᵐ[μ.map X] h2 := by
  have h_meas : MeasurableSet {y | h1 y = h2 y} :=
    measurableSet_eq_fun h1m h2m
  exact (MeasureTheory.ae_map_iff hX h_meas).2 h_eq

end Basic

section Existence

variable {β : Type*} [MeasurableSpace β] [TopologicalSpace β]
  [TopologicalSpace.PseudoMetrizableSpace β] [BorelSpace β]
  [Nonempty β] [StandardBorelSpace β]

/-- Doob-Dynkin factorization through `X` for sigmaX measurability.

This version uses the standard-borel hypothesis to obtain a measurable factor `h`.
-/
theorem doobDynkin_sigmaX (X : Ω → α) (g : Ω → β) (hg : Measurable[sigmaX X] g) :
    ∃ h : α → β, Measurable h ∧ g = h ∘ X := by
  have hg' : Measurable[MeasurableSpace.comap X (inferInstance : MeasurableSpace α)] g := by
    simpa [sigmaX] using hg
  simpa [sigmaX] using
    (Measurable.exists_eq_measurable_comp (f := X) (g := g) hg')

/-- Doob-Dynkin factorization for a.e. strongly measurable `g`.

This is the version used when only a.e. measurability is available.
-/
theorem doobDynkin_sigmaX_ae {μ : Measure Ω} (X : Ω → α) (g : Ω → β)
    (hg : AEStronglyMeasurable[sigmaX X] g μ) :
    ∃ h : α → β, Measurable h ∧ g =ᵐ[μ] h ∘ X := by
  classical
  have hg_meas : Measurable[sigmaX X] (hg.mk g) := hg.stronglyMeasurable_mk.measurable
  obtain ⟨h, hmeas, h_eq⟩ := doobDynkin_sigmaX (X := X) (g := hg.mk g) hg_meas
  refine ⟨h, hmeas, ?_⟩
  exact hg.ae_eq_mk.trans (Filter.EventuallyEq.of_eq h_eq)

end Existence

end DoobDynkin

/-!
## Light Versions (Real-Valued)

These are convenience lemmas for the most common econometric case `β = ℝ`.
-/

section DoobDynkinReal

variable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]

/-- Doob-Dynkin for real-valued `g`. -/
theorem doobDynkin_sigmaX_real (X : Ω → α) (g : Ω → ℝ) (hg : Measurable[sigmaX X] g) :
    ∃ h : α → ℝ, Measurable h ∧ g = h ∘ X :=
  doobDynkin_sigmaX (X := X) (g := g) hg

/-- Doob-Dynkin for a.e. strongly measurable real-valued `g`. -/
theorem doobDynkin_sigmaX_real_ae {μ : Measure Ω} (X : Ω → α) (g : Ω → ℝ)
    (hg : AEStronglyMeasurable[sigmaX X] g μ) :
    ∃ h : α → ℝ, Measurable h ∧ g =ᵐ[μ] h ∘ X :=
  doobDynkin_sigmaX_ae (X := X) (g := g) hg

end DoobDynkinReal

/-!
## Propensity Score as a Function of Covariates
-/

/-- A propensity score function e(x) with the property that e(X) matches the
conditional expectation of D given X (a.s.).

This packages the Doob-Dynkin step as an explicit structure so later theorems
can depend only on (e, X) rather than on the underlying conditional expectation. -/
structure PropensityScore {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]
    (mu : Measure Ω) (X : Ω → α) (D : Ω → Treatment) where
  e : α → ℝ
  measurable : Measurable e
  ae_eq : (fun ω => e (X ω)) =ᵐ[mu] propensityScoreRV mu X D

/-- The realized propensity score random variable e(X). -/
def PropensityScore.value {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]
    {mu : Measure Ω} {X : Ω → α} {D : Ω → Treatment}
    (ps : PropensityScore mu X D) : Ω → ℝ :=
  fun ω => ps.e (X ω)

lemma PropensityScore.value_measurable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]
    {mu : Measure Ω} {X : Ω → α} {D : Ω → Treatment}
    (ps : PropensityScore mu X D) : Measurable[sigmaX X] ps.value := by
  have hX : Measurable[sigmaX X] X := by
    simpa [sigmaX] using (comap_measurable (f := X))
  simpa [PropensityScore.value] using ps.measurable.comp hX

/-!
## Doob-Dynkin Construction
-/

/-- Existence of a measurable propensity score function `e(x)` with `e(X) = E[D|X]`. -/
theorem propensityScore_exists {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]
    (mu : Measure Ω) (X : Ω → α) (D : Ω → Treatment) :
    Nonempty (PropensityScore mu X D) := by
  classical
  have hmeas : Measurable[sigmaX X] (propensityScoreRV mu X D) :=
    propensityScoreRV_measurable mu X D
  obtain ⟨e, he_meas, h_eq⟩ :=
    doobDynkin_sigmaX (X := X) (g := propensityScoreRV mu X D) hmeas
  refine ⟨{ e := e, measurable := he_meas, ae_eq := ?_ }⟩
  have h_eq' : (fun ω => e (X ω)) = propensityScoreRV mu X D := by
    simpa [Function.comp] using h_eq.symm
  exact Filter.EventuallyEq.of_eq h_eq'

end Econometrics
